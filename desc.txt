Текстовый редактор с посветкой синтаксиса.
Компонент для использования в проектах WinForm.


+------+                +-------+    block input
| Form |--------------->| Input |-------------------+
|      |                +---V---+                   |
|      |                    |                       |
|      |   +--------+   +---V---+   +-------+   +---V---+
|      |<=>| Buffer |<--|  Text |<=>|  Lex  |<=>| Text  |
|      |   |  BMP   |   |  View |   |       |   | Data  |
|      |   +--------+   |       |   |       |   |       |
|      |                |       |   |       |   |       |
+------+                +-----A-+   +-V---A-+   +-V-----+
                              |       |   |       |
							  +-------+   +-------+  уведомления об изменениях строк

TextData	- хранилище данных
Lex			- лексический анализатор
TextView	- отображает фрагмент текста на экране (на форме)
TextInput	- разделяет входной поток от формы на команды перемещения курсора, формирует блоки изменений итп.

BufferBmp	- временно! для сокращения кода обработки onPaint
Form		- это - куда рисуем и откуда ввод от клавиатуры и мыши.



TextData
основные характеристики:
-- Хранилище текстовых данных.
-- Возможно подключение нескольких TextView к одному источнику. Для обеспечения целостности только один может быть активным.
-- Есть возможность Redo | Undo (ну это немного попозже)
-- Редактирование текста внутри хранилища выполняется блочными операциями:
		blockInsert(lineNum, pos, string)
		blockDelete(lineNum, pos, len)
		blockReplace(lineNum, pos, string)
		lineAdd(from, count)
		lineDelete(from, count) (можно и объеденить в принципе)

-- Должен обеспечивать работу в асинхронном режиме. (Напимер в случае применения сложных лексических анализаторов).



string GetLine(int lineNum)
возвращает текстовую строку. Потокобезопасный

event OnChangeLine(int lineNum)
генерируется при изменении строки.
все клиенты должны обеспечивать потокобезопасную обработку.

event OnLineInsert(int lineNum, int count) // потокобезопасный
генерируется при вставке или удалении строки. Позволит клиентам сохранять границы фрагмента если изменяется текст выше собственного.
??? position - на сколько сдвинулась неизменяемая строка lineNum. Здесь возможны варианты/

int GetLength() вводить не хочется. Для тексового файла это вещь малоинформативная :-( Ну пусть будет.



TextView
основные характеристики:
-- отображает фрагмент текста из хранилища.
-- Вывод на экран должен осуществляться по таймеру. "Не чаще чем N раз в секунду"
-- Имеет собственный буфер строк.
-- Между тиками таймера накапливает информацию об измененных строках и оптом их обновляет
-- В процессе вывода изображения выделяются фрагменты в разрезе стилей. те. сначала рисуются все красные фрагменты, потом зеленые ну итд.
		По идее это должно сократить накладные расходы...


TextInput
обработчик для событий от мыши и клавиатуры. 
-- Разделяет поток на блочный ввод, которы отправляет в хранилище и управляющие команды (перемещение курсора, например)

Lex
лексический анализатор.
-- Работает в отдельном потоке
-- Будет преобразовывать строки из хранилища в записи вида 
{
	string: ""
	[{style, len};...]
} те собственно строка и массив вида (стиль, длина).
Если массив не определен - используется стиль по умолчанию.

ну это в самом конце.

08.10.2018
Подробнее (детальнее) процесс отображения информации.
Основная идея проекта - реализация перерисовки текста по таймеру - те не чаще, чем N раз в секунду.
Причины для перерисовки бывают разные. 
Рассмотрим сл. варианты: 
1 - обновление информации внутри контрола.
2 - обработка метода Paint.
3 - изменение размера контрола.

будем рассматривать 2 варианта: без буфера и с буфером.

Сработал таймер и у нас есть набор строк - которые подлежат перерисовке.
------------------------------------------------------
2 - вариант
1. создаем контекст битмапа (буфер может не существовать - тогда пересоздадим)
2. для каждого цвета отрисовываем в него части измененных строк.
тут на выбор.
3.1 Вызываем invalidate для области, охваченной этими строками.
или
3.2 Берем контекст control и копируем в него области, охваченные этими строками

1 - вариант
1. Берем контекст control
2. для каждого цвета отрисовываем в него части измененных строк.

Вызван метод Paint.
-------------------
2 - вариант. 
1. Копируем область из буфера. Если буфера нет, то устанавливаем в список перерисовки все строки. Тогда контрол обновиться по таймеру.

1 - вариант.
1.1 Берем контекст из Paint
2.1 для каждого цвета отрисовываем в него части строк, попадающих в область отсечения.
или
1.2 отметим строки, которые попадают в область отсечения на перерисовку.

У нас изменился размер.
-----------------------
Возможные проблеммы в том, что уведомление об изменении размера рассылаются позже, чем винда пытается перерисовать контрол...

2 - вариант
Самое простое - сбросить битмап и выставить все строки в перерисовку.
Как вариант, если размер уменьшился - пересоздать буфер и скопировать в него изображение из старого.
Еще возможны варианты с увеличением размера только по вертикали. Тогда буфер можно пересоздать и скопировать исходный, а на перерисовку отметить только дополнительные строки.

1 - вариант
1. ничего не делаем :-)